export class LitVocabTerm extends URL {

  addLabel (a: string, b: string) {
    return this
  }
  addComment (a: string, b: string) {
    return this
  }
}

/**
 * Generated by ontology generator [${generatorClassname}]
 * from the source RDF file [${sourceRdfResource}]
 * at '${generatedTimestamp}'.
 */

const _NAMESPACE = 'http://www.w3.org/ns/auth/acl#'
function _NS (localName: any) { return (_NAMESPACE + localName) }

export const ACL = {
  NAMESPACE: _NAMESPACE,
  NS: _NS,

    // *****************
    // All the Classes.
    // *****************

    /**
     * A class of agents who have been authenticated.
     *  In other words, anyone can access this resource, but not anonymously.
     *  The social expectation is that the authentication process will provide an
     *  identify and a name, or pseudonym.
     *  (A new ID should not be minted for every access: the intent is that the user
     *  is able to continue to use the ID for continues interactions with peers,
     *  and for example to develop a reputation)
     */
  AuthenticatedAgent: new LitVocabTerm(_NS('AuthenticatedAgent'))
      .addLabel('', 'Anyone authenticated')
      .addComment('', `A class of agents who have been authenticated.
In other words, anyone can access this resource, but not anonymously.
The social expectation is that the authentication process will provide an
identify and a name, or pseudonym.
(A new ID should not be minted for every access: the intent is that the user
is able to continue to use the ID for continues interactions with peers,
and for example to develop a reputation)
`)
,

    /**
     * An element of access control,
     * allowing agent to agents access of some kind to resources or classes of resources
     */
  Authorization: new LitVocabTerm(_NS('Authorization'))
      .addLabel('', 'authorization')
      .addComment('', `An element of access control,
    allowing agent to agents access of some kind to resources or classes of resources`)
,

    /**
     * The class of read operations
     */
  Read: new LitVocabTerm(_NS('Read'))
      .addLabel('en', 'read')
      .addComment('', `The class of read operations`)
,

    /**
     *
     */
  Write: new LitVocabTerm(_NS('Write'))
      .addLabel('en', 'write')
,

    /**
     * Allows read/write access to the ACL for the resource(s)
     */
  Control: new LitVocabTerm(_NS('Control'))
      .addLabel('en', 'control')
      .addComment('', `Allows read/write access to the ACL for the resource(s)`)
,

    /**
     * Append accesses are specific write access which only add information, and do not remove information.
     * For text files, for example, append access allows bytes to be added onto the end of the file.
     * For RDF graphs, Append access allows adds triples to the graph but does not remove any.
     * Append access is useful for dropbox functionality.
     * Dropbox can be used for link notification, which the information added is a notification
     * that a some link has been made elsewhere relevant to the given resource.
     */
  Append: new LitVocabTerm(_NS('Append'))
      .addLabel('en', 'append')
      .addComment('', `Append accesses are specific write access which only add information, and do not remove information.
    For text files, for example, append access allows bytes to be added onto the end of the file.
    For RDF graphs, Append access allows adds triples to the graph but does not remove any.
    Append access is useful for dropbox functionality.
    Dropbox can be used for link notification, which the information added is a notification
    that a some link has been made elsewhere relevant to the given resource.
    `)
,

    /**
     * The information resource to which access is being granted.
     */
  accessTo: new LitVocabTerm(_NS('accessTo'))
      .addLabel('', 'to')
      .addComment('', `The information resource to which access is being granted.`)
,

    /**
     * If a resource has no ACL file (it is 404),
     *  then access to the resource if given by the ACL of the immediately
     *   containing directory, or failing that (404) the ACL of the recursively next
     *   containing directory which has an ACL file.
     *   Within that ACL file,
     *   any Authentication which has that directory as its acl:default applies to the
     *   resource. (The highest directory must have an ACL file.)
     */
  default: new LitVocabTerm(_NS('default'))
      .addLabel('', 'default access for things in this')
      .addComment('', `If a resource has no ACL file (it is 404),
        then access to the resource if given by the ACL of the immediately
        containing directory, or failing that (404) the ACL of the recursively next
        containing directory which has an ACL file.
        Within that ACL file,
        any Authentication which has that directory as its acl:default applies to the
        resource. (The highest directory must have an ACL file.)
`)
,

  /**
   * A person or social entity to being given the right
   */
  agent: new LitVocabTerm(_NS('agent'))
    .addLabel('', 'agent')
    .addComment('', `A person or social entity to being given the right`)
,

  /**
   * A group of persons or social entities to being given the right.
   *    The right is given to any entity which is a vcard:member of the group,
   *     as defined by the document received when the Group is dereferenced.
   */
  agentGroup: new LitVocabTerm(_NS('agentGroup'))
    .addLabel('', 'agent group')
    .addComment('', `A group of persons or social entities to being given the right.
        The right is given to any entity which is a vcard:member of the group,
        as defined by the document received when the Group is dereferenced.`)
,

  /**
   * A class of persons or social entities to being given the right
   */
  agentClass: new LitVocabTerm(_NS('agentClass'))
    .addLabel('', 'agent class')
    .addComment('', `A class of persons or social entities to being given the right`)
,

  /**
   * A mode of access such as read or write.
   */
  mode: new LitVocabTerm(_NS('mode'))
    .addLabel('', 'access mode')
    .addComment('', `A mode of access such as read or write.`)
,

  /**
   * A web application, identified by its Origin, such as
   *  &lt;https://scripts.example.com&gt;, being given the right.
   *  When a user of the web application at a certain origin accesses the server,
   *   then the browser sets the Origin: header to warn that a possibly untrusted webapp
   *  is being used.
   * Then, BOTH the user AND the origin must have the required access.
   */
  origin: new LitVocabTerm(_NS('origin'))
    .addLabel('', 'origin')
    .addComment('', `A web application, identified by its Origin, such as
      &lt;https://scripts.example.com&gt;, being given the right.
      When a user of the web application at a certain origin accesses the server,
      then the browser sets the Origin: header to warn that a possibly untrusted webapp
      is being used.
      Then, BOTH the user AND the origin must have the required access.`)
,

  /**
   *
   */
  trustedApp: new LitVocabTerm(_NS('trustedApp'))
,

  // *******************
  // All the Properties.
  // *******************

  //
  // Marker allowing us put commas at the end of all lines above (only the last line does not have a comma).
  //
  END_OF_VOCAB: 'End of vocab.'
}
